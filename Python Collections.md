判断一个collection是不是空，



## 字符串
- **字符串的创建（常量表达）**
```python
s = "" # 空字符串。
# 单引号和双引号的意义是一样的
a = 'spam eggs'
b = "spam eggs"
# 字符串常量跨行（不是多行字符串，只是为了替代换行符而已）
a = ('aaa'
'bbb'
'ccc')
# 引号里面有引号
a = 'doesn\'t'  # doesn't 用 \'将引号转义
a = "\"Yes,\" he said."
a = "doesn't"  # 或者混用单双引号
a = '"Yes," he said.'  # "Yes," he said.
# 反斜杠\加上一些符号，代表特殊的字节编码——转义序列
s = 'First line.\nSecond line.'  # 换行符
# r避免转义——row字符串
s = r'C:\some\name'
# 多行字符串，三重引号（三重引号也会用作文档字符串、块注释）
string = '''how
are
you'''
string = 'how \n are \n you' # 多行字符串的等效形式
```

- **序列操作**
序列：包含其他对象的有序集合，通过位置索引。序列：Str/List/Tuple
映射：包含其他对象的无序集合，通过键索引。映射：dict
for循环是迭代操作。for循环、列表解析（本质也是for循环），是通用的迭代工具，遵循迭代协议。迭代协议：一个内存中的序列、或一个迭代操作中，每次都产生一个元素。
列表解析、map、filter 比 for循环快很多，但Python 程序优先考虑简单和可读性，其次再考虑优化和性能，所以最广泛的还是for循环。
字符串是由很多’单字符串’构成的序列。字符串是一个有序的字符的集合。Python没有C-like的char单字符类型，字符串的基本组成是单个字符‘单字符串’。
字符串支持**通用的序列操作**：
    1. 索引和分片。注意，绝对不能越界。
    ```python
    #索引
    print s[0] # 正向索引index，从左至右
    print s[-1] # 反向索引，从右至左，相当于 s[len(s)-1]
    #切片
    s[ M : N ]   切片，在序列 s 中，取出偏移量为M，直到但不包括偏移量为 N 的内容，最后得到一个新对象。
    #常见切片
    s[1:]    # 去除首位
    s[:-1]   # 去除末位
    s[:]    # 完整复制
    #序列索引的原理，以"python"为例。
    #位置是“从哪儿切下”，索引是取切口右侧的元素，而切片是取切下的区间的元素。
     +---+---+---+---+---+---+
     | P | y | t | h | o | n |
     +---+---+---+---+---+---+
     0   1   2   3   4   5   6
    -6  -5  -4  -3  -2  -1
    ```
    2. 重复和拼接
    字符串拼接：见官方 Doc
	不可变性：字符串／元组／数字创建后就不可变，而列表和字典可变。
    ```python
    s = 3 * 'un' + 'ium'
    s = ‘something’
	s = ‘do ’ + s   # 变量 s 的确变为 ‘do something’, 但这是形成新的字符串对象，引用赋予变量s
    ```
	3. 计算长度
	4.     ```python
    len(s) #计算出长度
    ```

- **字符串特定的操作**
astring.upper()   # 通用操作与特有操作是不同的
字符串特有的函数：find  replace lower upper split join strip
字符串格式化：% 与 format

- **模式匹配 re 模块**
搜索／分割／替换，但因为它支持模式定义，所以更通用。

##列表
列表是一个任意类型的对象的位置相关的有序集合。大小可变。最通用的序列。
L.append(’s’)  # 在末尾添加一个对象
L.pop(2)  # 指定删除一个索引值的对象
del L[2]  # 指定删除一个索引值的对象
insert／remove
L.sort()  # 按照 ASCII 生序排列
L.reverse()  # 将原来的顺序 ，反向排列
列表可以嵌套，最常用的是组建多维数组（最常见的是矩阵）和 json 这样的复杂数据。

列表解析式


P63-P70，模块


#####元组 tuple
元组，任意类型、任意嵌套。不可变的序列，与列表很相似。
除了序列的共有方法，list的列表修改是无法应用于tuple 的，但是tuple又有自己独特的方法
	t =  (‘a’,’b’,’c’,’d’)
	m = t.index(‘c’)  # 得出一个元素的索引值。结果为2
	n = t.count(‘c’)  # 得出一个元素出现的次数。结果为1

## 字典
字典是一种映射，也是Python中唯一的映射。映射是一个其他对象的集合，通过键值对来存储对象。大小可变。
如果一个对象是可变的（比如列表list），那么它不可散列Unhashable，就不能作为集合set的元素，也不能作为字典dict的键。
d = {}  # 创建空字典
d = {‘food’：‘spam’，‘weight’：4，‘color‘：’red‘}  # 用键值对创建一个字典
d[’food‘]  # 用键读取值
d[’weight‘] += 1  # 重新赋值，就是改变key对应的value
d[‘name’] = ‘apple’  # 增加一个键值对。可以创建{}，然后不断增加键值对

字典和列表一起，可以轻松地组建 json那样的复杂／高级数据结构。C／C++需要先设计／声明结构和数组，填写值，然后拼接，非常麻烦。
字典可以迭代遍历key：  for key in d：print d[key]
有时候需要按照一定的顺序遍历：
方法1
	keylist = list（d.keys() ）   # 提取所有的key，组建一个list
	for key in keylist.sort():     # list排序，然后遍历
		print d[key]            # 用key 提取 value
方法 2  for key in sorted(d): print d[key]    # 一步完成，效果一样
字典取值，也要特别注意『越界』问题——如果key不存在，会引发异常。避免的手段：
	value = d.get(‘x’,0)   # 如果’x’键不存在，就使用默认值 0
	value = d[‘x’] if ‘x’in d else 0 # 具有相同的效果
	还可以用has_key方法、try语句

