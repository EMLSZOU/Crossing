Python语句按照顺序运行（上下左右），除非使用流程语句进行跳跃。
不用{}或者begin/end或者分号，用缩进判断逻辑，而一行的末尾就是这句语句的结尾。
空格、空行、注释都会被忽略。文档字符串（Docstring）会被忽略，但会被保存。
有人说这种语法是“所见即所得”，代码和逻辑一致。这样更容易维护和重用。

字符串跨行
```
a = """aaa
bbb
ccc"""

a = ('aaa'
'bbb'
'ccc')
```


# 表达式
常见表达式
```
a = var  # 读取一个变量，并且赋值
function(arg)  # 调用函数
object.function(arg)  # 调用实例的一个方法
yield x**2
print(a,b,sep='')  # 打印
```
##### 调用函数、返回值
注意：有些函数没有返回值，返回的是None对象，它的作用是对传入的参数对象作原处修改。
append()、sort()、reverse都是
```
alist = [1,2]
alist.append(3)  # 结果 alist = [1,2,3]
# 但是有些人不知道原处修改的函数没有返回值，最后丢失了列表对象
alist = alist.append(4)  # 结果  alist=None
```

#### 打印
有2种打印：
1.写入文件：file.write(str) 将对象转成字符串，然后将字符串写入文件；
2.标准输出流stdout：与标准输入流、错误流（异常跟踪）是程序启动的3种数据连接。一般打印到启动脚本的窗口，但是因为本质是sys.stdout对象，所以可以通过重定向写入文件。

Python2 与 Python3 的 print语法很不一样
- Python3，print()是一个函数，用函数参数来指定模式和功能（标准的函数调用语法）
- Python2，print是一个语句，用特定的语法来指定模式和功能（临时性的语法）

##### Python3的打印
```
print([object1,object2...]  [,sep=' ']  [,end='\n']  [,file=sys.stdout])
```
- object1,object2...：传入的需要打印的对象，用逗号分隔。print函数将它们传给内置str()函数，变为“用户友好”字符串。
- sep=' '：指定各个对象打印出来的间隔，默认是一个空格。
- end='\n'：指定添加在打印文本末尾的字符串，默认是换行符（也就是一个print语句会换一行）。
- file=sys.stdout：指定将输出流发送的地点（任何带有write(str)方法的文件、标准流等），默认是标准流 sys.stdout，也就是打印到屏幕。

```
a,b,c = 1,'you',['me']
print(a,b,c,sep='...',end='!\n')  # 结果 1...you...me!
```
虽然print()的sep和end参数很方便，但是最好还是自己定制一个格式：
```
text = '%s: %-.4f, %05d' % ('result', 3.1415926, 42)
print(text)  # result：3.1416,00042
```


##### Python2的打印
```
print [>> file=sys.stdout]  [object1,object2...]  [,]  [,file=sys.stdout]
```
- object1,object2...：传入的需要打印的对象，用逗号分隔。print函数将它们传给内置str()函数，变为“用户友好”字符串。
- ，：加了逗号，就不会换行
- ’>> file=sys.stdout‘：指定将输出流发送的地点（任何带有write(str)方法的文件、标准流等），默认是标准流 sys.stdout，也就是打印到屏幕。

取消中间的空格，有2个方法：
- print a+b+c  # 最好别这么写
- print '%s...%s...%s' % (a,b,c)  # 推荐写法

让Python2 也能支持 print()
```
from __future__ import print_function
print(1)
print('a', 'b', 'c')  # 并不可靠，有些Python版本会打印出元组  ('a', 'b', 'c')
# 更可靠的同时打印多个对象的方式————格式化字符串，自定义格式
print(%s %s %s % ('a', 'b', 'c'))
print('{} {} {}'.format('a', 'b', 'c'))
```


#### 重定向
实际上，打印和写入文件，是对等的。
print(a,b) 和 print a,b 等价于
```
import sys
sys.stdout.write(str(a)+' '+str(b)+'\n')
```
这，就是重定向的原理。

1.永久重定向（这次运行的整个过程都重定向）
    ```
    import sys
    sys.stdout = open('log.txt', 'a')
    # 此后，每个print语句都被重定向了。
    ```
2.暂时性重定向（只在重定向这一次打印）
这需要一个文件对象（它有write(str)方法，而不是一个文件名字符串）
```
print(a,b,c,file=open(log.txt,'a'))  # 重定向语句
print >> open(log.txt,'a'),a,b,c  # Python2语法
```
这就像永久重定向后，恢复
```
origin = sys.stdout
sys.stdout = open(log.txt,'a')
print(a,b,c)
sys.stdout.close()
sys.stdout = origin
```
标准打印和重定向的原理：
```
print(a,b)  # 标准流
sys.stdout.write(str(a)+' '+str(b)+'\n')  # 标准流的原理
print(a,b,c,file=open(log.txt,'a'))  # 重定向语句
open(log.txt,'a').write(str(a)+' '+str(b)+'\n')  # 重定向的原理
print >> open(log.txt,'a'),a,b,c  # Python2语法
```


# 选择和分支————if 语句
#### 布尔运算
在Python里，任何非零、非空对象都为真。数字0、空对象（[]和''之类）、None都为假。比较和相等，会在数据结构中递归运算。运算符是 and or not，而不是 && || !!。计算返回的True False对象（而不是数值）。

```
if <test1>:
    <statement1>
elif <test2>:
    <statement2>
else:
    <statement3>
```
Python 没有C-like语言的 switch 语句，但是有替代方案：
**java**
```
switch (selector){
	case value1:
        <statement1>;
		break;
	case value2:
        <statement2>;
		break;
    default:
        <statement3>;
}
```
**Python 1**  如果分支很多，将会非常冗长
```
if selector == value1: <statement1>
elif selector == value2:<statement2>
else:<statement3>
```
**Python 2**  用字典，然后取值，更简洁
```
branch = {value1:statement1,value2:statement2}
if selector in branch: branch[selector]
else: statement3  # default语句
# 更优化的写法
branch.get(selector,statement3)  # get方法，如果键不存在，就取默认值
```

### 三元选择符
Python没有三元选择符，但是也可以实现。

java
```
a = condition ? value1 : value2
```
Python 有3中实现方式
```
a = value1 if condition else value2
a = (value2, value1)[condition]
a = condition and value1 or value2
```

# 循环————while 和 for 语句

### while语句
语法
```
while test:
	statement1  # 条件成立才执行
else:
	statement2  # 没有遇到break，正常离开循环，才执行
```
无限循环
```
while True:print('Ctrl-C to stop')
```
do-while
Python没有 do-while，但是也可以实现"执行一次，再循环，条件成立就退出"
```
while True:
	statement
    if exitTest: break
```
循环切片
```
x = 'spam'
while x:  # 等价于 x != ''
	print(x,end=' ')
    x = x[1:]
```
为什么while要有else?
```

```


#### 控制语句
pass：占位语句，暂时填充位置，也可以用来忽略异常，定义空类/空函数。





