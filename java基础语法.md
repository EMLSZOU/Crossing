# Java Bean规范
JavaBean不是语法规范，而是建议。按照这种规则写的类也称为POJO类（Plan Old Java Object）
JDK的类几乎都符合JavaBean规范。如：String类,集合类。
简化规范：
    1) 必须有包（package）
    2) Java类，具有无参数构造器
    3) 有用getXxx() 和  setXxx() 声明的Bean属性。如：getName() 和  setName(String n) 声明的Bean属性为：name
    4) 必须实现序列化接口（注：在学习IO的时候具体学习）

- - -

### static静态关键字
static修饰：属性、方法、内部类、代码块
##### static 属性
使用static修饰的属性，属于类的全体类的实例共享的变量，是属于类级别（类下的所有对象实例共享）的资源。
- 静态属性：在类的加载期间初始化；使用类名.属性访问，如：System.out
- 实例变量：属于对象的属性；使用对象.属性访问，如：person.name
##### static 方法
使用static声明的方法，属于类的方法（静态方法），一般用来表示工具方法。在类加载以后就可以调用, 不需要创建任何类的实例对象。
```java
public class Main {
	public static void main(String[] args) {
		System.out.println("静态方法调用：" + M.add(5, 7) + "静态变量访问：" + M.y);
	}
}
class M {
	int x = 2; // 这是实例变量
	static int y = 10; // 这是静态变量，类变量
	public static int add(int a, int b) {
		return a + b;
	}
}
```
##### 静态代码块、内部类（省略）
静态代码块是在类加载期间运行的代码块，由于类只加载一次，所以静态代码块只执行一次！
静态代码块用途不是很常见,一般用来在类加载以后初始化一些静态资源时候使用

- - -

### final关键字
- final 修饰的类，不能再被继承。Java 的String、Math，包装类（Integer 、Long、Character等）是final类。
- final修饰的方法，不能被覆盖。
    在实际项目开发中，最好不要使用final类和方法！因为Spring, Hibernate,Struts 2 等框架使用了"动态继承代理"技术，final类和方法会影响"动态代理技术" 的实现。
- final 修饰的变量，初始化以后不允许再修改了。包括局部变量、方法参数、成员变量
	final的局部变量，只能初始化不能改
	final 的方法参数，不能改
	final 的引用，引用指向不能改，但是对象的属性可以改
- final static --常量。C/C++用const作为常量的修饰符，而java是 final static 。final修饰属性表示“不能改”，static修饰属性表示属于类的“仅此一份”。
    一般要求常量名都有大写字母  `final static double PI = 3.14159;`
- 的

* * *


# 抽象类 和 接口
### 抽象类 abstract class
抽象类一般没有足够的信息来描述一个具体的对象，抽象类只用于继承，不能用于创建对象。
一个抽象类一般包括一个或多个抽象方法(只有方法说明,没有方法体)。
抽象类的子类必须实现其父类定义的每一个抽象方法,若没有实现父类的所有抽象方法，则该子类也应该定义为抽象类.

1、抽象类的实现
抽象类abstract修饰，其格式是：
	abstract class 类名
	{
		类成员定义
	}
抽象类也可以包含非抽象的方法。
继承抽象类的非抽象子类必须覆盖父类中定义的抽象方法。
2、抽象方法（abstract method）
抽象方法用abstract修饰，它没有方法体。
抽象方法的格式是：
	abstract 返回类型 方法名（[参数]）；
抽象方法只能出现在抽象类中。
含有抽象方法的类必须定义成抽象类。
几点注意事项：
    (1) 构造方法不能定义为抽象方法。
    (2) 最终方法不能说明为抽象方法。
    (3)  static和private修饰符不能用于抽象方法。

求常见平面图形（如三角形、圆、矩形和正方形等）的面积。利用抽象类，编写程序实现该功能。
各种平面图形都可以求出其面积，但不同的形状求面积的方法不同，因此可以定义一个平面图形形状类Shape。Shape类中有一个求面积的抽象方法(area)，只所以定义为抽象方法是因为不同的平面图形求法不同。圆(Circle)、矩形(Rectangle)和三角形(Triangle)是不同的形状，它们都是Shape的子类，而正方形(Square)是矩形(Rectangle)中的一种特殊类型，因此正方形是矩形的子类，如下图所示。抽象类的类名在类图中要用斜体表示，以区别于普通的类。

电在传输上都会有损耗，假如计算电费时区分冬季和夏季用电情况，冬季在用电原有读数上加上20千瓦小时作为用电损耗，而夏季没有此损耗问题。电费是每千瓦小时电0.49元，假定用电度数为125千瓦小时，利用抽象类，分别计算出冬季和夏季相应的电费。


### 接口 interface

只有抽象方法的抽象类?

 可以用接口来表示 

用接口代替这样的抽象类，是因为：


接口有比抽象类更好的特性：
1.可以被多继承
2.设计和实现完全分离
3.更自然的使用多态
4.更容易搭建程序框架
5.更容易更换实现
 …… 
接口功能
(1) 通过接口可以实现不相干类的相同行为而不需考虑这些类之间的层次关系。
(2) 通过接口可以实现多继承机制。
(3) 通过接口可以了解对象的交互界面而不需了解对象所对应的类。




如何使用接口
 USB接口本身没有实现任何功能，只规定了数据传输的要求
 USB接口可以被多种USB设备实现
 USB接口可以被多种设备使用
Java接口
根据需求设计方法。编写接口
实现所有方法。子类继承，实现接口
用多态的方式使用。实例化子类，使用接口
编写接口
public interface InterfaceName {
    // 常量定义
    // 所有常量可以是public、static和final。禁止private和protected
    final String name="Name";
    final String sex="male";
    //所有定义在接口中的方法，默认为public和abstract
    void aInterfaceExample(parameterList);
}



实现接口
一个类可以使用implements实现多个接口，。从而实现多继承的机制。
实现接口的类必须实现接口中的所有方法。否则为抽象类。
在类中实现接口中定义的方法时，不能比接口中定义的方法有更低的访问权限。因此，被实现的接口方法必须用public修饰。

public class UDisk implements InterfaceA, InterFaceB {
    public void service() {
        System.out.println("连接USB口，开始传输数据。");
    }
}
使用接口
UsbInterface uDisk = new UDisk();
uDisk.service();

接口是一系列没有实现的方法和常量的组合，是个功能模块。
 接口隐含修饰符为abstract
没有public的接口，其访问将局限于该类所属的包。
接口继承通过关键字extends来实现，其语法与类继承相同，而且一个接口可以继承多个接口。在类的继承中，所有的类，其超类均为Object，而接口没有所谓的超接口。

接口是一种约定
生活中，我们使用的两相电源插座，规定了：
两个接头间的额定电压
两个接头间的距离
接头的形状
接口是一种约定：体现在接口名称和注释上。有些接口只有名称。方法的实现方式要通过注释来约定
面向接口编程： 程序设计时面向接口的约定而不考虑具体实现 

必须知道的接口特性
接口不可以被实例化， 常作为类型使用 

实现类必须实现接口的所有方法， 抽象类除外 

实现类可以实现多个接口，Java中的多继承

接口中的变量都是静态常量

#### 接口和类之间的区别
（1）类只能继承一个类，而对于接口，可以实现继承多个接口。
（2）对于继承性，类继承了父类的方法，子类可以选择是否覆盖父类的方法。
（3）接口的方法没有实现，因此，类必须实现接口中的每个方法。
 (4) 接口不能声明变量，只能声明常量
#### 抽象类与接口的比较
抽象类和接口的有些特性是相似的，如：
    抽象类和接口都不能用来实例化对象。
    可以声明抽象类和接口的变量，但对抽象类来说，要用抽象类的非抽象子类来实例化该变量；对接口来说，要用实现了该接口的非抽象子类来实例化该变量。
    一个子类如果没有实现抽象类中声明的所有抽象方法，那么该子类也是一个抽象类；一个类如果没有实现接口中声明的所有方法，那么该类也是一个抽象类。
    抽象类和接口都可以实现程序的多态性。
尽管抽象类和接口有些相似的特性，但它们在本质上是有很大区别的：
    抽象类在Java语言中体现的是一个“父与子”的关系，即抽象类与子类之间必须存在“子类是父类中的一种”关系，如抽象类“水果”与子类“苹果”之间就存在“苹果是一种水果”的关系。而接口与接口的实现者之间不必有“父与子”的关系，接口的实现者只是具有接口中定义的行为而已。
    抽象类中可以定义非抽象的方法，而接口中的所有方法都是抽象的。
    接口中的数据成员只能是常量。
    在抽象类中增加一个方法并赋予其默认的行为（即增加一个非抽象的方法），并不一定要修改子类，但如果接口被修改了，即增加或去掉了某个功能，则所有实现了该接口的类一定要重新修改。
练习1：实现抽象类  Shape, 和Shape具体实现类Circle, Rectangle  
	Shape中定义抽象方法contains 检查点是否在图形内部, 在子类中实现.   
	1）Shape提供抽象的计算面积方法area，子类实现   
	2) Shape提供抽象的检查是否包含指定坐标的方法，子类实现   
	3) Circle 继承与Shape 继承属性location 作为圆心   
	扩展属性  int r 作为圆的半径,  覆盖技术面积的方法和包含指定点的方法   
	4) Rectangle继承与Shape 继承属性location 作为位置,   
	扩展属性  int w, int h 作为宽高
练习2：实现扑克牌类Card  
	1) 创建54张扑克牌   
	2) 洗牌   
	3) 发牌到3个人（Player）   
	√  Player属性   
	. String name   
	. Card[] cards = {};   
	注意：人每次接收牌的时候需要扩展cards数组  


# 多态
频繁修改代码，代码可扩展性、可维护性差————使用多态优化设计
生活中，同一种事物，由于条件不同产生的结果也不同，这是很常见的。
Java中，用父类变量名引用子类对象，这样，同一个引用类型，使用不同的实例而执行不同操作。
 实现多态的两个要素：
1. 子类继承时，方法重写
    方法重写的规则
    在继承关系的子类中
    重写的方法名、参数、返回值类型必须与父类相同
    私有方法不能继承因而也无法重写
    |       | 位置 | 方法名 | 参数表 | 返回值 | 访问修饰符 |
    |-------|--------|--------|--------|--------|--------|
    |方法重写| 子类 | 相同   | 相同   | 相同   | 不能比父类更严格 |
    |方法重载| 同类 | 相同   | 不相同 | 无关    | 无关 |
2. 使用父类类型














